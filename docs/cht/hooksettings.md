# HOOK設置

## 通用設置

1. #### 代碼頁

    ::: info
    這一設置當且僅當從遊戲中提取的文本是**HOOK引擎內部未指定編碼**的**多字節字符串**時纔有意義，當HOOK引擎內部已經指定了代碼頁，或者文本是**寬字符字符串**或者**UTF32**字符串時，這一設置沒有任何意義
    :::

    這一設置一般沒有修改的必要，當且僅當部分古老引擎(例如Yuris)的官方中文版可能會有GBK/BIG5/UTF8。如果找不到正確的文本，直接向我發[issue](https://lunatranslator.org/Resource/game_support)，修改這個設置通常是徒勞的。

1. #### 刷新延遲

    如果你面臨以下情況之一：

        1. 文本每次就提取出一兩個字；
        2. 文本每次提取出一行，然後把上一行頂掉，最後只顯示最後一行；
        3. 文本正確，但是提取的好慢；

    那麼你需要調整這個選項。

    對於**1、2**兩種情況，因爲遊戲文本顯示的太慢了，而刷新延遲太低，導致每提取到一兩個字、或者提取到一行文本，就立即刷新出來了。對此，你需要做的是，**提高刷新延遲**，或者提高遊戲的文顯示速度。

    對於**3**，你可以**適當的降低刷新延遲**，降低值的同時注意不要出現**1、2**的情況。

1. #### 最大緩衝區長度

    有時，文本會反覆的不停刷新，這時，如果刷新延遲較高且不能降低，會導致一直接收文本直到文本填滿緩衝區、或不再刷新以滿足刷新延遲(通常是遊戲失去焦點時才停止刷新，因此一般是等到填滿緩衝區)。

    爲了解決這個問題，可以適當降低緩衝區長度，且要注意不要使緩衝區長度過低到小於實際文本長度。

1. #### 最大緩存文本長度

    接收到的歷史文本會被緩存下來，當在文本選擇窗口中，查看某條文本的內容時，會查詢歷史緩存文本。如果文本條目過多，或因文本反覆刷新，會導致緩存的文本過多，查看文本時會變得較爲卡頓(有時甚至不查看時也會卡頓)。實際上這裏緩存的大部分都是無用文本，有用的歷史文本可以在歷史文本窗口裏面查看，可以將這個數值隨意調低（默認是1000000，但其實調到1000就行）。

## 遊戲的專用設置

1. #### 額外的鉤子
    1. #### Win32通用鉤子
        激活後，將會一定向遊戲中注入Win32的通用函數鉤子，包括GDI函數、D3DX函數、字符串函數。

        注入太多的鉤子可能導致遊戲速度變慢，因此默認不會注入這些鉤子。

        當無法提取到正確的文本時，可以嘗試激活這兩個選項。
    1. #### 特殊碼
        當**插入特殊碼**並**選中特殊碼的文本**時，纔會記錄這個條特殊碼，下一次啓動時會自動插入這條特殊碼。這個設置中記錄了之前記錄的所有特殊碼，可以在其中添加或刪除特殊碼。

1. #### 延遲注入
    有時，遊戲需要被插入鉤子的位置在dll上，需要遊戲稍微運行一小會兒後，纔會加載dll。我們也需要等dll加載後，再進行注入

1. #### 專用HOOK設置
    在設置界面->HOOK設置中，進行的設置是默認設置，當未爲遊戲指定專用的HOOK設置時，會採用默認設置。

    若要對遊戲進行專用HOOK設置，需要在**遊戲管理**中，打開**遊戲設置**界面，在其中的遊戲設置選擇卡中，切換到HOOK子選項卡，取消**跟隨默認**後，即可爲遊戲設置專用的HOOK設置。

    ::: details
    ![img](https://image.lunatranslator.org/zh/gamesettings/1.jpg)

    ![img](https://image.lunatranslator.org/zh/gamesettings/2.png)
    :::

## 特殊碼格式

1. #### HOOK

    `{H|B}{A|B|C|W|I|S|Q|U|V}[F][N][codepage#][padding+]data_offset[*deref_offset][:split_offset[*deref_offset]]@addr[:module[:func]]`

    H是inlineHook，B是vehhook

    單字符：A/B是小端/大端的mbcs，C是UTF8，W是UTF16，I是UTF32。

    字符串：S是默認ascii字符串，Q是UTF16，U是UTF32，V是UTF8。

    F：每次讀取字符串後添加換行符

    N：無視上下文

    寄存器的data_offset：
      * 32位 EAX -4, ECX -8, EDX -C, EBX -10, ESP -14, EBP -18, ESI -1C, EDI -20
      * 64位 RAX -C, RBX -14, RCX -1C, RDX -24, RSP -2C, RBP -34, RSI -3C, RDI -44, R8 -4C, R9 -54, R10 -5C, R11 -64, R12 -6C, R13 -74, R14 -7C, R15 -84

1. #### JIT HOOK

    `{H|B}{A|B|C|W|I|S|Q|M|U|V}[F][N][codepage#][padding+]arg_index[*deref_offset][:split_offset[*deref_offset]]@{info}:JIT:{UNITY|YUZU|PPSSPP|VITA3K|RPCS3}`

    arg_index是JIT函數的參數index。M爲C#字符串，僅UNITY可用。

    UNITY的info爲：[程序集]:[命名空間]:[類名]:[函數名]:[參數量]

    YUZU/PPSSPP/VITA3K/RPCS3的info爲被模擬地址

1. #### 內嵌

    `E[D][S][N|O]HOOKCODE`

    E是使用內嵌的標註，HOOKCODE是JIT特殊碼或HOOK特殊碼。

    D：寫入時轉換中文字符爲日語字符集

    S：提取時使用HOOKCODE指定的文本提取方式

    N：寫入時創建新的字符串並交換字符串指針

    O：寫入時在原字符串上覆寫

1. #### 直接內存讀取

    `R{S|Q|V|U}[codepage#]@addr`

    R是直接內存讀取的標誌

    S是默認ascii字符串，Q是UTF16，U是UTF32，V是UTF8